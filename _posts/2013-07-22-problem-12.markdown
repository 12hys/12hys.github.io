---
layout: post
title: "Problem 12"
date: 2013-07-22 21:59
comments: true
categories: 
---
Solution to Problem 12. Written in Python.

Problem: The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be: 1, 3, 6, 10, 15, 21, 28, 36, 45, 55,â€¦

Let us list the factors of the first seven triangle numbers:

**1:** 1  
**3:** 1,3  
**6:** 1,2,3,6  
**10:** 1,2,5,10  
**15:** 1,3,5,15  
**21:** 1,3,7,21  
**28:** 1,2,4,7,14,28  

We can see that 28 is the first triangle number to have over five divisors. What is the value of the first triangle number to have over five hundred divisors?

UPDATE: I've reattempted this problem and found a much faster solution.

```python
#!/usr/local/bin/pypy

import euler_lib as lib

sieve = lib.eratosthenes_sieve(100000)
triangle_numbers = [1]
i = 2
ptr = 0
end = 1000000

while i < end:
    triangle_numbers.append(triangle_numbers[ptr] + i)
    ptr = ptr + 1
    i = i + 1

for i in triangle_numbers:
    if lib.divisor_count_with_sieve(i, sieve) > 500:
        print i
        break
```

Original Solution:

```python
#this is a VERY inefficient solution,
#it takes a long time to compute

#wikipedia
def eratosthenes_sieve(n):
    candidates = list(range(n+1))
    fin = int(n**0.5)
    for i in xrange(2, fin+1):
        if candidates[i]:
            candidates[2*i::i] = [None] * (n//i - 1)
    return [i for i in candidates[2:] if i]

numberofprimes = 20000000
print( 'Loading primes...' )
primes = eratosthenes_sieve(numberofprimes)
print( 'Done loading primes...' )

def increment(x):
    return x+1

def numOfDivisors(triangleNumber):
    factor = []     #returns the prime factors of a number
    factorization = []  #returns a factorization of the elements in the factor list above. there exists a bijection between factor and factorization
    for x in primes:
        if(triangleNumber % x == 0):
            factor.append(x)
    for x in factor:
        tempCtr = 1
        temp = triangleNumber / x
        while(temp % x == 0):
            tempCtr += 1
            temp = temp / x
        factorization.append(tempCtr)
    temp = map(increment, factorization)
    return reduce(lambda x, y: x*y, temp)
    
found = False
tnumberctr = 10
while(found == False and tnumberctr < numberofprimes):
    triangleNumber = sum(range(1,tnumberctr+1)) #calculates the triangle number
    numofdivs = numOfDivisors(triangleNumber)   #prime factorization method of returning number of divisors of a triangle number
    if numofdivs > 200:
        print( str(triangleNumber) + ': ' + str(numofdivs) )
    
    if(numofdivs >= 500):
        found = True
    else:
        tnumberctr += 1
```